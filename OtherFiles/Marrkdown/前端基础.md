# 前端基础

# 1. ES6

## 1.1 var 和 let 关键字的区别

- let 声明的变量不存在越域现象；
- let 声明的变量不存在变量提升；
- let 关键字不可以重复声明变量。

## 1.2 解构表达式

### 1.2.1 数组解构

``` javascript
let arr = [1,2,3];

// 以前的写法
let a = arr[0];
let b = arr[1];
let c = arr[2];

// 解构表达式
let [a,b,c] = arr;
```

### 1.2.2 对象解构

```javascript
const person = {
    name: "jack",
    age: 21,
}

// 以前的写法
const name = person.name;
const age = person.age;

// 对象解构，等价于 const name = person.name;
const {name, age} = person;
// 等价于 const n = person.name;
const {name: n, age: a} = person;
```

## 1.3 字符串扩展

``` javascript
let str = "hello, string";

// true
console.log(str.startWith("hello"));
// true
console.log(str.endWith("string"));
// true
console.log(str.includes("e"))
```

## 1.4 字符串模板

### 1.4.1 多行字符串

```javascript
let str = `
	<div>
		<span>Hello ES6!</span>
	<d/iv>
`;
```

### 1.4.2 字符串插值和变量表达式

变量名写在 \${} 中，\${} 中可以放入 JavaScript 表达式。

```javascript
function fun() {
    return "我是一个函数"
};

let info = '我是${name}, 今年${age + 10}岁，我想说:"${fun()}"';
```

## 1.5 函数优化

### 1.5.1 参数默认值

```javascript
function add1(a, b) {
    // 判断 b 是否为空，为空则给默认值
    b = b
    !!1;
    return a + b;
}

// 传一个参数
log.add1(10);

// 在 ES6 中可以直接给参数提供默认值
function add2(a, b = 1) {
    return a + b;
}

log.add2(10);
```

### 1.5.2 不定参数

```javascript
function fun(...values) {
    console.log(values.length);
}

fun(1);
fun(1, 2);
```

### 1.5.3 箭头函数

```javascript
// 以前
var print1 = function (obj) {
    console.log(obj);
};

var sum1 = function (a, b) {
    c = a + b;

    return a + c;
}

// ES6
var print2 = obj => console.log(obj);
print("Hello!");

var sum2 = (a, b) => {
    c = a + b;

    return a + c;
};
console.log(sum2(1 + 2));

const person = {
    name: "jack",
    age: 21,
}

// 箭头函数 + 解构：{name} 表示解构出传入对象的 name 属性
var hello = ({name}) => console.log("hello" + name);
hello(person);
```

## 1.6 对象优化

### 1.6.1 新增的 API

```javascript
const person = {
    name: "jack",
    age: 21,
}

// ["name"m "age"]
console.log(Object.keys(person));
// ["jack", "21"]
console.log(Object.values(person));
// [["name", "jack"], ["age", 21]]
console.log(Object.entrys(person));

const target = {a: 1};
const source1 = {b: 2};
const source2 = {c: 3};

Object.assign(target, source1, source2)
// {a: 1, b: 2, c: 3}
console.log(target);
```

### 1.6.2 声明对象简写

```javascript
const age = 23;
const name = "Jack";

// 以前声明对象
const person1 = {age: age, name: name};

// ES6：如果属性名和属性值的变量名相同，可简写为如下代码
const person2 = {age, name};
```

### 1.6.3 对象的函数属性简写

```javascript
// 以前
const person = {
    name: "jack",
    age: 21,
    eat1: function (food) {
        console.log(this.name + "吃" + food);
    },
// 箭头函数无法使用 this，必须使用 对象.属性
    eat2: food => console.log(this.name + "吃" + food),

    eat3(food) {
        console.log(this.name + "吃" + food);
    },
}
```

### 1.6.4 对象的扩展运算符

扩展运算符（...）用于取出传的入对象中所有可遍历属性然后拷贝到当前对象。

```javascript
const person1 = {
    name: "jack",
    age: 21,
}

// 拷贝对象（深拷贝）
const someone = {...person}

// 合并对象
let name = {name: Jack};
let age = {age: 15};
let person2 = {...name, ...age};
```

## 1.7 map 和 reduce

数组中新增了 map 和 reduce 方法：

- map()：接受一个函数，将元数组中所有元素用这个函数处理后放入新数组返回；
- reduce(callback, [initialValue])：为数组中的每一个元素依次执行回调函数，不包括数组中国被删除或从未被赋值的元素。
    - previousValue：上次调用回调函数返回的值或提供的初始值；
    - currentValue：数组中当前被处理的元素；
    - index：当前元素在数组中的索引；
    - array：调用 reduce 的数组。

```javascript
let arr = ["1", "2"];

let result1 = arr.map(item => item * 2);

let result2 = arr.reduce((a, b) => {
    console.log("上一次处理后：" + a);
    console.log("当前正在处理：" + b);
    return a + b;
}, 100);

console.log(result);
```

## 1.8 Promise

Promise 可以封装异步操作

```javascript
let p = Promise((resolve, reject) => {
    // 异步操作
    $.ajax({
        url: 'mock/user.json',
        success: function (data) {
            console.log("查询用户成功：", data);
            resolve(data);
        },
        error: function (err) {
            reject(err);
        }
    });
});

p.then((data) => {
    return new Promice((resolve, reject) => {
        $.ajax({
            url: `mock/user_corse_${data.id}.json`,
            success: function (data) {
                console.log("查询用户课程成功：", data);
                resolve(data);
            },
            error: function (err) {
                reject(err)
            }
        });
    });
}).then((data) => {
    console.log("上一步的结果：" + data);
    $.ajax({
        url: `mock/corse_score_${data.id}.json`,
        success: function (data) {
            console.log("查询课程得分成功：", data);
            resolve(data);
        },
        error: function (err) {
            reject(err)
        }
    });
})

function get(url, data) {
    return new Promise((resolve, reject) => {
        $.ajax({
            url: url,
            data: data,
            success: function (data) {
                resolve(data);
            },
            error: function (err) {
                reject(err)
            }
        })
    });
}

get("mock/user.json")
    .then((data) => {
        console.log("用户查询成功：", data);
        return get(`mock/user_corse_${data.id}.json`);
    })
    .then((data) => {
        console.log("用户课程查询成功：", data);
        return get(`mock/corse_score_${data.id}.json`);
    })
    .then((data) => {
        console.log("课程成绩查询成功：", data);
    })
    .catch((err) => {
        console.log("出现异常：", err);
    })
```

# 2. Vue

## 2.1 MVVM 思想

- M：Model，模型，包括数据和一些基本操作；
- V：View，视图，页面渲染的结果；
- VM：View-Model：模型与视图之间的双向操作（无需开发人员干涉）。

在 MVVM 之前，开发热源从后端获取需要的数据模型，然后要通过 DOM 操作 Model 渲染到 VIew 中。而后当用户操作视图，我们还需要通过
DOM 获取 View 中的数据，然后同步到 Model 中。

而 MVVM 中的 VM 需要做的事情就是把 DOM 操作完全封装起来，开发人员不用关心 Model 和 View 之间是如何相互影响的。

## 2.2 Vue 基础

Vue 是一套用于构建用户界面的渐进式框架，与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue
的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目进行整合。另一方面，与现代化的工具链及各种支持类库结合使用时，Vue
也能完全为复杂的单页应用提供驱动。

 



